TITLE POLINOM

;Программа вычисления и построения графика функции вида
; Y=a1Xn + a2Xn-1 + …+ anX +an+1
.MODEL SMALL ;Модель памяти ближнего типа.
.STACK 256 ;Отвести под стек 256 байт.
.486 ;Используем расширенную систему команд.
.DATA ;Открыть сегмент данных.
Mas_A DW -3, 3, -6, 9, -20 ;Коэффициенты полинома.
N DW 4 ;Порядок полинома равен 4.
X DD -10.0 ;Начальное значение аргумента X.
M DW 180 ;Масштабный коэффициент.
Step DD 0.1 ;Шаг изменения аргумента X.
Number DW 0 ;Номер отсчёта для значений X.
Y DD (?) ;Результат вычисления полинома.
;--------------------------------------------------------
.CODE ;Открыть сегмент кодов.
;========== Инициализация графического режима =============
InitGraph PROC
pusha
mov AH, 0 ;Установить режим экрана
mov AL, 13h ;320x200x256
int 10h ;средствами BIOS.
popa
ret
InitGraph ENDP
;============== Закрытие графического режима ==============
CloseGraph PROC
mov AX, 3 ;Установить текстовый
int 10h ;режим 25x80 средствами BIOS.
ret
CloseGraph ENDP
;================ Очистка экрана ========================
Clear PROC
pusha
mov CX, 64000 ;Число пикселов экрана.
mov AX, 0A000h ;Адрес графической видеопамяти
mov ES, AX ;в ES.
mov AL, 00010100b
xor DI, DI
cld
rep stosb
popa
ret
Clear ENDP
;=============== Ожидание нажатия клавиши ===============
WaitKey PROC
pusha
mov AH, 01h
int 21h
popa
ret
WaitKey ENDP
;================ Рисование осей ========================
Osi PROC
pusha
mov CX, 10 ;x горизонталь
mov DX, 100 ;y
mov AL, 00000110b ;Цвет оси желтый
o1: mov AH, 12 ;Вывод точки.
int 10h ;Вызов BIOS.
inc CX ;Построить
cmp CX, 300 ;300
jne o1 ;точек.
mov CX, 160 ;x вертикаль
mov DX, 0 ;y
mov AL, 00000110b ;Цвет оси желтый.
o2: mov AH, 12 ;Вывод точки
int 10h
inc DX
cmp DX, 200
jne o2
popa
ret
Osi ENDP
;================ Вывод точки на экран ===================
PutPixel PROC
;ecx, edx – координаты точки
pusha
mov AL,0000010b ;Цвет пиксела - зелёный
mov EDX, 3 ;Номер строки y
sub EDX, Y ;вывода
nop ;задержка
mov CX, 60 ;Номер столбца x
add CX, Number ;вывода.
nop
mov AH,12 ;Вывести пиксел
int 10h ;на экран
nop
popa
ret
PutPixel ENDP
;------------------------------------------------------------- 
Start: mov AX, @Data
mov DS, AX
call Clear ;очистка журнала
call InitGraph ;инициализация графического режима
call Osi ;построение осей графика
call WaitKey ;Ожидание нажатия клавиши
@2: mov CX, N ;Загрузить счетчик циклов.
xor SI,SI ;если сравниваемые биты отличаются (не равны) =1
finit ;Инициализировать сопроцессор.
fild Mas_A[SI] ;Загрузка a1 в вершину стека
fld X ;Загрузить X в st(1).
@1: fmul ;Перемножть st(0):=(st(0))*(st(1)).
inc SI ;Перейти к следующему
inc SI ;ai.
fiadd Mas_A[SI] ;Добавить очередное ai к произведению.
fld X ;Загрузить X в st(1).
loop @1 ;Перейти на метку, если CX не 0.
fxch st(1) ;Обменять st(0) и st(1).
fidiv M ;Разделить на масштабный коэффициент.
frndint ;Округлить до целого.
fistp Y ;Переслать (st(0)) в Y.
call PutPixel ;Вывести полученное значение на график.
fadd Step ;Увеличить на шаг st(0):=(st(0))+0.1.
fstp X ;Сохранить st(0)+0.1 в память Z.
inc Number ;Перейти к следующему отсчету по X.
cmp Number,199 ;Повторить еще 199 раз.
jnz @2 ;если не равно 0 то
call WaitKey ;Ожидание нажатия клавиши
call CloseGraph ;Закрыть графический режим
mov AX, 4C00h ;и выйти
int 21h ;в DOS.
END Start