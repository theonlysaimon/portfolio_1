.MODEL SMALL ;Модель памяти ближнего типа.
.STACK 100h ;Отвести под стек 256 байт.

.DATA ;Открыть сегментданных.
Mas_A DW -2, 8, -5, 0, 1 ;Коэффициенты полинома.
N DW 4 ;Порядок полинома равен 4.
X DW 10 ;Аргумент полинома равен 10.
Y DW (?) ;Результат вычисления полинома.
Mes_1 DB 'OVERFLOW', 13, 10, '$' ;Сообщение MES_1.
Mes_2 DB 'RESULT MINUS', 13, 10, '$' ;Сообщение MES_2.
Mes_3 DB 'RESULT PLUS', 13, 10, '$' ;Сообщение MES_3.
Res DB 'Y = -2*10^4 + 8*10^3 + -5*10^2 + 0*10 + 1', 13, 10, '$'
Y_res DB 'Y = ', '$'
Y_Asc DB 7 DUP(?) ;Переменная для хранения символов ASCII.
Sign DB (?) ;Переменная для хранения знака числа.
Numb DW Y ;Переменная для хранения исходного числа.
;------------------------------------------------------------------------------------------
.CODE ;Открыть сегмент кодов.

PREOBR PROC ;Начать процедуру с именем PREOBR.
    MOV AX, Numb ;Поместить в AX исходное число.
    MOV Sign, ' ' ;Поместить в переменную знака ;символ пробела (знак +).
    CMP AX, 0; ;Сравнить число с нулем.
    JNS M_1; ;Если больше или равно 0, перейтина ;метку М_1,
    MOV Sign, '-' ;иначе поместить в переменную знака ;символ минус (знак –).
    NEG AX ;Преобразовать в прямой код.
M_1: 
    XOR CX, CX ;Очистить CX.
    MOV BX, 10 ;Поместить в ВХ делитель равный 10.
M_2: 
    XOR DX, DX ;очистить DX
    DIV BX ;деление AX на BX
    PUSH DX ;Сохранить остаток в стеке.
    INC CX ;СX +1
    CMP AX, 0 ;проверка AX >= 0
    JNE M_2 ;Если (АХ) не равно 0, повторить деление.
    XOR SI, SI ;Очистить SI.
    MOV AL, Sign ;Загрузить в AL знак числа.
    MOV Y_Asc[SI], AL ;Переслать знак в Y_ASCII.
    INC SI
M_3: 
    POP AX ;Извлечь содержимое стека в AX.
    ADD AL, 30h ;Вычислить ASCII код для цифры.
    MOV Y_Asc[SI] ,AL ;Переслать ASCII код в Y_ASCII.
    INC SI ;SI +1
    LOOP M_3 ;Если содержимое СХ не 0, повторить цикл.
    MOV Y_Asc[SI], '$' ;Поместить символ конца строки в Y_ASCII.
RET ;Возврат из процедуры.
PREOBR ENDP ;Завершить процедуру с именем PREOBR.

Main: 
    mov AX, @Data ;инизиализация
    mov DS, AX ;сегментный региср DS
    lea SI, Mas_A ;загрузить в SI начальный адрес
    mov CX, N ;пересылка в CX значение адреса Mas_A
    xor DX, DX ;очистка DX
    mov AX,[SI] ;пересылка в AX начальное значание массива Mas_A
F_1: 
    imul X ;умножение числа X со знаком
    jo Mes1 ;показ сообщения о переполнении
    add SI, 2 ;SI +2
    add AX, [SI] ;прибавление к AX текущего значения SI(3)
    jo Mes1 ;показ сообщения о переполнении
    loop F_1 ;возвращение к M_1 до тех пор пока CX != 0
    mov Y, AX ;пересылка в Y значения AX
    cmp AX, 0 ;сравнение AX с 0, если AX <= 0
    jge Mes3 ;то переход к Mes3

    mov DX, offset Res ;Вывод сообщения
    mov AH, 09 ;на
    int 21h ;экран.

    mov DX, offset Mes_2 ;Вывод сообщения
    mov AH, 09 ;на
    int 21h ;экран.

    mov DX, offset Y_res ;Вывод сообщения
    mov AH, 09 ;на
    int 21h ;экран.

    CALL PREOBR ;Вызов процедуры преобразования
    
    mov DX, offset Y_Asc ;Вывод сообщения
    mov AH, 09 ;на
    int 21h ;экран.

Exit: 
    mov AL, 0 ;пересылка в AL значение 0
    mov AH, 4Ch ;функция DOS завершения программы
    int 21h ;завершить программу
Res1:
    mov DX, offset Res ;Вывод сообщения
    mov AH,09 ;на
    int 21h ;экран.
Mes1: 
    mov DX, offset Mes_1 ;Вывод сообщения
    mov AH,09 ;на
    int 21h ;экран.
    jmp Exit
Mes3: 
    mov DX, offset Mes_3 ;Вывод сообщения
    mov AH, 09 ;на
    int 21h ;экран.
    jmp Exit

END Main