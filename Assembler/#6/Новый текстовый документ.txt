
PREOBR PROC ;Начать процедуру с именем PREOBR.
    MOV AX, Numb ;Поместить в AX исходное число.
    MOV Sign, ' ' ;Поместить в переменную знака ;символ пробела (знак +).
    CMP AX, 0; ;Сравнить число с нулем.
    JNS M_1; ;Если больше или равно 0, перейтина ;метку М_1,
    MOV Sign, '-' ;иначе поместить в переменную знака ;символ минус (знак –).
    NEG AX ;Преобразовать в прямой код.
M_1: 
    XOR CX, CX ;Очистить CX.
    MOV BX, 10 ;Поместить в ВХ делитель равный 10.
M_2: 
    XOR DX, DX ;очистить DX
    DIV BX ;деление AX на BX
    PUSH DX ;Сохранить остаток в стеке.
    INC CX ;СX +1
    CMP AX, 0 ;проверка AX >= 0
    JNE M_2 ;Если (АХ) не равно 0, повторить деление.
    XOR SI, SI ;Очистить SI.
    MOV AL, Sign ;Загрузить в AL знак числа.
    MOV Y_Asc[SI], AL ;Переслать знак в Y_ASCII.
    INC SI
M_3: 
    POP AX ;Извлечь содержимое стека в AX.
    ADD AL, 30h ;Вычислить ASCII код для цифры.
    MOV Y_Asc[SI] ,AL ;Переслать ASCII код в Y_ASCII.
    INC SI ;SI +1
    LOOP M_3 ;Если содержимое СХ не 0, повторить цикл.
    MOV Y_Asc[SI], '$' ;Поместить символ конца строки в Y_ASCII.
RET ;Возврат из процедуры.
PREOBR ENDP ;Завершить процедуру с именем PREOBR.



    mov DX, offset Res ;Вывод сообщения
    mov AH, 09 ;на
    int 21h ;экран.

    mov DX, offset Y_res ;Вывод сообщения
    mov AH, 09 ;на
    int 21h ;экран.

    CALL PREOBR ;Вызов процедуры преобразования
    
    mov DX, offset Y_Asc ;Вывод сообщения
    mov AH, 09 ;на
    int 21h ;экран.